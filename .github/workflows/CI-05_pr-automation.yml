ks from branch protection: ${requiredChecks.join(', ')}`);
            }
          } catch (error) {
            console.log(`‚ö†Ô∏è Could not fetch branch protection rules: ${error.message}`);
          }
          
          // Combine check runs and commit statuses for complete picture
          const allChecks = [
            ...relevantChecks.map(check => ({
              name: check.name,
              conclusion: check.conclusion,
              status: check.status,
              type: 'check_run',
              details_url: check.details_url,
              summary: check.output?.summary,
              started_at: check.started_at,
              completed_at: check.completed_at
            })),
            ...commitStatuses.map(status => ({
              name: status.context,
              conclusion: status.state === 'success' ? 'success' : (status.state === 'pending' ? null : 'failure'),
              status: status.state === 'pending' ? 'in_progress' : 'completed',
              type: 'status',
              details_url: status.target_url,
              summary: status.description
            }))
          ];
          
          console.log(`üìä Total checks found: ${allChecks.length} (${relevantChecks.length} check runs, ${commitStatuses.length} statuses)`);
          
          // Check completion status
          const allChecksPassed = allChecks.every(check => 
            check.conclusion === 'success' || check.conclusion === 'skipped' || check.conclusion === 'neutral'
          );
          
          const anyPending = allChecks.some(check => 
            check.conclusion === null || 
            check.status === 'in_progress' || 
            check.status === 'queued' ||
            check.status === 'pending'
          );
          
          const failedChecks = allChecks.filter(check => 
            check.conclusion === 'failure' || 
            check.conclusion === 'cancelled' ||
            check.conclusion === 'timed_out' ||
            check.conclusion === 'action_required'
          );
          
          // Log detailed status
          console.log(`‚úÖ Passed: ${allChecks.filter(c => c.conclusion === 'success').length}`);
          console.log(`‚è≥ Pending: ${allChecks.filter(c => c.conclusion === null || c.status === 'in_progress' || c.status === 'queued' || c.status === 'pending').length}`);
          console.log(`‚ùå Failed: ${failedChecks.length}`);
          console.log(`‚è≠Ô∏è Skipped: ${allChecks.filter(c => c.conclusion === 'skipped').length}`);
          
          if (anyPending) {
            const pendingChecks = allChecks.filter(c => 
              c.conclusion === null || 
              c.status === 'in_progress' || 
              c.status === 'queued' ||
              c.status === 'pending'
            );
            console.log(`‚è≥ Checks still running (${pendingChecks.length}): ${pendingChecks.map(c => c.name).join(', ')}`);
            return;
          }
          
          // Check if we have any checks at all (avoid auto-merge with no checks)
          if (allChecks.length === 0 && requiredChecks.length === 0) {
            console.log('‚ö†Ô∏è No checks found and no required checks configured. Waiting for checks to start...');
            return;
          }
          
          if (!allChecksPassed) {
            console.log(`‚ùå ${failedChecks.length} check(s) failed - notifying Jules`);
            
            // Create detailed failure report with enhanced information
            let failureReport = '## ‚ùå Failed Checks Summary\n\n';
            failureReport += `**Total Checks:** ${allChecks.length} | **Failed:** ${failedChecks.length} | **Passed:** ${allChecks.filter(c => c.conclusion === 'success').length}\n\n`;
            failureReport += '### Failed Checks Details\n\n';
            
            for (const check of failedChecks) {
              const emoji = check.conclusion === 'cancelled' ? 'üö´' : 
                           check.conclusion === 'timed_out' ? '‚è±Ô∏è' : 
                           check.conclusion === 'action_required' ? '‚ö†Ô∏è' : '‚ùå';
              
              failureReport += `${emoji} **${check.name}** (${check.type})\n`;
              failureReport += `   - **Status:** ${check.conclusion}\n`;
              
              if (check.summary) {
                const truncatedSummary = check.summary.length > 200 
                  ? check.summary.substring(0, 200) + '...' 
                  : check.summary;
                failureReport += `   - **Summary:** ${truncatedSummary}\n`;
              }
              
              if (check.details_url) {
                failureReport += `   - **Details:** [View Full Log](${check.details_url})\n`;
              }
              
              if (check.started_at && check.completed_at) {
                const duration = Math.round((new Date(check.completed_at) - new Date(check.started_at)) / 1000);
                failureReport += `   - **Duration:** ${duration}s\n`;
              }
              
              failureReport += '\n';
            }
            
            failureReport += '\n### üîß Next Steps\n\n';
            failureReport += '1. Click on the "View Full Log" links above to see detailed error messages\n';
            failureReport += '2. Fix the issues in your code\n';
            failureReport += '3. Push the changes to update this PR\n';
            failureReport += '4. Checks will automatically re-run and auto-merge will retry when they pass\n';
            
            if (failedChecks.some(c => c.name.includes('test'))) {
              failureReport += '\nüí° **Tip:** Test failures often indicate logic errors. Run tests locally to debug faster.\n';
            }
            if (failedChecks.some(c => c.name.includes('lint') || c.name.includes('format'))) {
              failureReport += '\nüí° **Tip:** Run `cargo fmt` and `cargo clippy` locally to fix formatting and lint issues.\n';
            }
            if (failedChecks.some(c => c.name.includes('build'))) {
              failureReport += '\nüí° **Tip:** Build failures might be due to compilation errors or missing dependencies.\n';
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `@jules ‚ö†Ô∏è **Checks Failed - Action Required**\n\n${failureReport}`
            });
            return;
          }
          
          // Check for requested changes
          const { data: reviews } = await github.rest.pulls.listReviews({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: prNumber
          });
          
          const hasRequestedChanges = reviews.some(r => r.state === 'CHANGES_REQUESTED');
          if (hasRequestedChanges) {
            console.log('‚ùå Changes requested - cannot auto-merge');
            return;
          }
          
          // All good - merge!
          console.log('‚úÖ All checks passed - merging...');
          
          try {
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              commit_title: `ü§ñ Auto-merge: ${pr.title}`,
              commit_message: `Jules PR #${prNumber} - All checks passed\n\n${pr.body || ''}`,
              merge_method: 'squash'
            });
            
            console.log('‚úÖ Merged successfully!');
            
            // Add success comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `‚úÖ **Auto-merged successfully!** All checks passed and the PR has been merged.`
            });
            
            // Store PR number for next workflow
            core.setOutput('merged_pr', prNumber);
            core.setOutput('pr_merged', 'true');
            
          } catch (error) {
            console.error('‚ùå Merge failed:', error.message);
            
            // Provide detailed error analysis
            let errorAnalysis = '### üîç Error Analysis\n\n';
            let nextSteps = '### üîß Next Steps\n\n';
            
            if (error.message.includes('merge conflict') || error.message.includes('conflict')) {
              errorAnalysis += '**Cause:** Merge conflicts detected\n';
              nextSteps += '1. Update your branch with the latest changes from the base branch\n';
              nextSteps += '2. Resolve any conflicts locally\n';
              nextSteps += '3. Push the resolved changes\n';
            } else if (error.message.includes('required status check') || error.message.includes('branch protection')) {
              errorAnalysis += '**Cause:** Branch protection requirements not met\n';
              nextSteps += '1. Ensure all required status checks have passed\n';
              nextSteps += '2. Check if review approvals are required\n';
              nextSteps += '3. Verify branch is up to date with base\n';
            } else if (error.message.includes('not mergeable') || error.message.includes('mergeable_state')) {
              errorAnalysis += '**Cause:** PR is not in a mergeable state\n';
              nextSteps += '1. Wait for all checks to complete\n';
              nextSteps += '2. Refresh the PR status\n';
              nextSteps += '3. Check for merge conflicts\n';
            } else {
              errorAnalysis += `**Cause:** ${error.message}\n`;
              nextSteps += '1. Review the error message above\n';
              nextSteps += '2. Check the PR status manually\n';
              nextSteps += '3. Contact maintainers if issue persists\n';
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `@jules ‚ö†Ô∏è **Auto-merge Failed**\n\n${errorAnalysis}\n${nextSteps}\n---\n**Technical Details:** \`${error.message}\``
            });
          }
name: "CI-05: PR Auto-Merge"

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled]
  check_suite:
    types: [completed]
  workflow_run:
    workflows: ["CI-01: Build & Test"]
    types: [completed]
  workflow_dispatch:

env:
  # Set to 'false' to disable auto-merge temporarily
  AUTO_MERGE_ENABLED: true

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: read

jobs:
  # Auto-merge for Jules PRs with failure handling
  auto-merge:
    name: Auto-Merge Jules PR
    runs-on: ubuntu-latest
    if: |
      (github.event.pull_request &&
       (contains(github.event.pull_request.labels.*.name, 'jules-pr') || 
        contains(github.event.pull_request.body, 'Created by Jules')) &&
       github.event.pull_request.draft == false &&
       env.AUTO_MERGE_ENABLED == 'true') ||
      (github.event.workflow_run &&
       github.event.workflow_run.conclusion != 'skipped' &&
       env.AUTO_MERGE_ENABLED == 'true') ||
      github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Find Jules PR for workflow run
      id: find-pr
      if: github.event_name == 'workflow_run'
      uses: actions/github-script@v7
      with:
        script: |
          const run = context.payload.workflow_run;
          const { data: prs } = await github.rest.pulls.list({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open'
          });
          
          // Find PR matching the workflow run head SHA
          const pr = prs.find(p => 
            p.head.sha === run.head_sha &&
            (p.labels.some(l => l.name === 'jules-pr') || (p.body && p.body.includes('Created by Jules')))
          );
          
          if (pr) {
            core.setOutput('pr_number', pr.number);
            core.setOutput('has_pr', 'true');
          } else {
            core.setOutput('has_pr', 'false');
          }

    - name: Check for check failures and comment if needed
      id: check-failures
      uses: actions/github-script@v7
      env:
        PR_FROM_EVENT: ${{ github.event.pull_request.number || '' }}
        PR_FROM_WORKFLOW: ${{ steps.find-pr.outputs.pr_number || '' }}
      with:
        script: |
          // Determine PR number
          let prNumber = process.env.PR_FROM_EVENT || process.env.PR_FROM_WORKFLOW;
          if (!prNumber && context.payload.issue) {
            prNumber = context.payload.issue.number;
          }
          
          if (!prNumber) {
            console.log('‚è≠Ô∏è No PR to process for checks');
            return;
          }
          
          prNumber = parseInt(prNumber);
          console.log(`üîç Checking checks for PR #${prNumber}`);
          
          // Get check suites for the PR
          const { data: checkSuites } = await github.rest.checks.listSuitesForRef({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: context.payload.pull_request?.head.sha || context.payload.workflow_run?.head_sha
          });
          
          let hasFailures = false;
          let failureDetails = [];
          
          for (const suite of checkSuites.check_suites) {
            const { data: checks } = await github.rest.checks.listForSuite({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_suite_id: suite.id
            });
            
            for (const check of checks.check_runs) {
              if (check.conclusion === 'failure' || check.conclusion === 'error') {
                hasFailures = true;
                failureDetails.push({
                  name: check.name,
                  output: check.output
                });
              }
            }
          }
          
          if (hasFailures) {
            // Generate analysis using Copilot-like logic (simplified AI analysis)
            let analysis = '### ü§ñ Copilot-Analyse der Check-Fehler:\n\n';
            failureDetails.forEach((failure, index) => {
              analysis += `#### Fehler ${index + 1}: ${failure.name}\n`;
              analysis += `**Meldung:** ${failure.output.title || 'Keine spezifische Meldung'}\n`;
              if (failure.output.summary) {
                analysis += `**Details:** ${failure.output.summary}\n`;
              }
              // Basic solution suggestions based on common Rust/CI issues
              if (failure.name.includes('test') && failure.output.summary.includes('failed')) {
                analysis += `**L√∂sungsansatz:** √úberpr√ºfe die Testf√§lle auf Assertions-Fehler. F√ºhre \`cargo test -- --nocapture\` lokal aus, um detaillierte Ausgaben zu sehen. Stelle sicher, dass alle Abh√§ngigkeiten korrekt sind.\n\n`;
              } else if (failure.name.includes('clippy') && failure.output.summary.includes('warning')) {
                analysis += `**L√∂sungsansatz:** Clippy-Warnungen beheben. F√ºhre \`cargo clippy --fix\` aus, um automatische Korrekturen anzuwenden. √úberpr√ºfe Rust-API-Guidelines f√ºr Stil-Konformit√§t.\n\n`;
              } else if (failure.name.includes('fmt') && failure.output.summary.includes('format')) {
                analysis += `**L√∂sungsansatz:** Code-Formatierung anpassen. F√ºhre \`cargo fmt\` aus, um den Code automatisch zu formatieren.\n\n`;
              } else {
                analysis += `**L√∂sungsansatz:** √úberpr√ºfe die vollst√§ndigen Logs f√ºr weitere Details. Konsultiere die Projekt-Dokumentation in \`docs/\` oder \`AGENTS.md\` f√ºr spezifische Guidelines.\n\n`;
              }
            });
            
            // Comment on PR
            const commentBody = `@jules Es wurden Check-Fehler in diesem PR entdeckt. Bitte behebe sie, um den Auto-Merge zu erm√∂glichen.\n\n${analysis}`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: commentBody
            });
            
            core.setOutput('has_failures', 'true');
          } else {
            core.setOutput('has_failures', 'false');
          }

    - name: Auto-merge Jules PR if all checks pass
      uses: actions/github-script@v7
      env:
        PR_FROM_EVENT: ${{ github.event.pull_request.number || '' }}
        PR_FROM_WORKFLOW: ${{ steps.find-pr.outputs.pr_number || '' }}
      with:
        script: |
          // Determine PR number
          let prNumber = process.env.PR_FROM_EVENT || process.env.PR_FROM_WORKFLOW;
          if (!prNumber && context.payload.issue) {
            prNumber = context.payload.issue.number;
          }
          
          if (!prNumber) {
            console.log('‚è≠Ô∏è No PR to process');
            return;
          }
          
          prNumber = parseInt(prNumber);
          console.log(`ü§ñ Jules PR Auto-Merge: #${prNumber}`);
          
          // Get latest PR state
          const { data: pr } = await github.rest.pulls.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: prNumber
          });
          
          // Check if it's a Jules PR
          const isJulesPR = pr.labels.some(l => l.name === 'jules-pr') || 
                           (pr.body && pr.body.includes('Created by Jules'));
          if (!isJulesPR) {
            console.log('‚è≠Ô∏è Not a Jules PR - skipping');
            return;
          }
          
          // Check mergeable state
          if (pr.mergeable === false) {
            console.log('‚ùå PR is not mergeable');
            return;
          }
          
          // Get check suites
          const { data: checkSuites } = await github.rest.checks.listSuitesForRef({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: pr.head.sha
          });
          
          let allChecksPassed = true;
          for (const suite of checkSuites.check_suites) {
            if (suite.conclusion === 'failure' || suite.conclusion === 'error') {
              allChecksPassed = false;
              break;
            }
          }
          
          if (!allChecksPassed) {
            console.log('‚ùå Not all checks passed - cannot auto-merge');
            return;
          }
          
          // Auto-merge if enabled
          if (process.env.AUTO_MERGE_ENABLED === 'true') {
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              merge_method: 'squash'
            });
            console.log('‚úÖ Auto-merged Jules PR');
            
            // Update CHANGELOG.md (existing logic, assuming it's in CI-06)
            // Note: Actual changelog update is handled by CI-06_update-changelog.yml
          } else {
            console.log('‚è≠Ô∏è Auto-merge disabled');
          }
