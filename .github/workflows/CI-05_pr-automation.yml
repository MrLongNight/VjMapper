name: "CI-05: PR Auto-Merge"

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled]
  check_suite:
    types: [completed]
  workflow_run:
    workflows: ["CI-01: Build & Test"]
    types: [completed]
  workflow_dispatch:

env:
  # Set to 'false' to disable auto-merge temporarily
  AUTO_MERGE_ENABLED: true

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: read

jobs:
  # Auto-merge for Jules PRs with failure handling
  auto-merge:
    name: Auto-Merge Jules PR
    runs-on: ubuntu-latest
    if: |
      (github.event.pull_request &&
       (contains(github.event.pull_request.labels.*.name, 'jules-pr') || 
        contains(github.event.pull_request.body, 'Created by Jules')) &&
       github.event.pull_request.draft == false &&
       env.AUTO_MERGE_ENABLED == 'true') ||
      (github.event.workflow_run &&
       github.event.workflow_run.conclusion != 'skipped' &&
       env.AUTO_MERGE_ENABLED == 'true') ||
      github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Find Jules PR for workflow run
      id: find-pr
      if: github.event_name == 'workflow_run'
      uses: actions/github-script@v7
      with:
        script: |
          const run = context.payload.workflow_run;
          const { data: prs } = await github.rest.pulls.list({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open'
          });
          
          // Find PR matching the workflow run head SHA
          const pr = prs.find(p => 
            p.head.sha === run.head_sha &&
            (p.labels.some(l => l.name === 'jules-pr') || (p.body && p.body.includes('Created by Jules')))
          );
          
          if (pr) {
            core.setOutput('pr_number', pr.number);
            core.setOutput('has_pr', 'true');
          } else {
            core.setOutput('has_pr', 'false');
          }

    - name: Check for check failures and comment if needed
      id: check-failures
      uses: actions/github-script@v7
      env:
        PR_FROM_EVENT: ${{ github.event.pull_request.number || '' }}
        PR_FROM_WORKFLOW: ${{ steps.find-pr.outputs.pr_number || '' }}
      with:
        script: |
          // Determine PR number
          let prNumber = process.env.PR_FROM_EVENT || process.env.PR_FROM_WORKFLOW;
          if (!prNumber && context.payload.issue) {
            prNumber = context.payload.issue.number;
          }
          
          if (!prNumber) {
            console.log('‚è≠Ô∏è No PR to process for checks');
            return;
          }
          
          prNumber = parseInt(prNumber);
          console.log(`üîç Checking checks for PR #${prNumber}`);
          
          // Get check suites for the PR
          const { data: checkSuites } = await github.rest.checks.listSuitesForRef({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: context.payload.pull_request?.head.sha || context.payload.workflow_run?.head_sha
          });
          
          let hasFailures = false;
          let failureDetails = [];
          
          for (const suite of checkSuites.check_suites) {
            const { data: checks } = await github.rest.checks.listForSuite({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_suite_id: suite.id
            });
            
            for (const check of checks.check_runs) {
              if (check.conclusion === 'failure' || check.conclusion === 'error') {
                hasFailures = true;
                failureDetails.push({
                  name: check.name,
                  output: check.output
                });
              }
            }
          }
          
          if (hasFailures) {
            // Generate analysis using Copilot-like logic (simplified AI analysis)
            let analysis = '### ü§ñ Copilot-Analyse der Check-Fehler:\n\n';
            failureDetails.forEach((failure, index) => {
              analysis += `#### Fehler ${index + 1}: ${failure.name}\n`;
              analysis += `**Meldung:** ${failure.output.title || 'Keine spezifische Meldung'}\n`;
              if (failure.output.summary) {
                analysis += `**Details:** ${failure.output.summary}\n`;
              }
              // Basic solution suggestions based on common Rust/CI issues
              if (failure.name.includes('test') && failure.output.summary.includes('failed')) {
                analysis += `**L√∂sungsansatz:** √úberpr√ºfe die Testf√§lle auf Assertions-Fehler. F√ºhre \`cargo test -- --nocapture\` lokal aus, um detaillierte Ausgaben zu sehen. Stelle sicher, dass alle Abh√§ngigkeiten korrekt sind.\n\n`;
              } else if (failure.name.includes('clippy') && failure.output.summary.includes('warning')) {
                analysis += `**L√∂sungsansatz:** Clippy-Warnungen beheben. F√ºhre \`cargo clippy --fix\` aus, um automatische Korrekturen anzuwenden. √úberpr√ºfe Rust-API-Guidelines f√ºr Stil-Konformit√§t.\n\n`;
              } else if (failure.name.includes('fmt') && failure.output.summary.includes('format')) {
                analysis += `**L√∂sungsansatz:** Code-Formatierung anpassen. F√ºhre \`cargo fmt\` aus, um den Code automatisch zu formatieren.\n\n`;
              } else {
                analysis += `**L√∂sungsansatz:** √úberpr√ºfe die vollst√§ndigen Logs f√ºr weitere Details. Konsultiere die Projekt-Dokumentation in \`docs/\` oder \`AGENTS.md\` f√ºr spezifische Guidelines.\n\n`;
              }
            });
            
            // Comment on PR
            const commentBody = `@jules Es wurden Check-Fehler in diesem PR entdeckt. Bitte behebe sie, um den Auto-Merge zu erm√∂glichen.\n\n${analysis}`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: commentBody
            });
            
            core.setOutput('has_failures', 'true');
          } else {
            core.setOutput('has_failures', 'false');
          }

    - name: Auto-merge Jules PR if all checks pass
      uses: actions/github-script@v7
      env:
        PR_FROM_EVENT: ${{ github.event.pull_request.number || '' }}
        PR_FROM_WORKFLOW: ${{ steps.find-pr.outputs.pr_number || '' }}
      with:
        script: |
          // Determine PR number
          let prNumber = process.env.PR_FROM_EVENT || process.env.PR_FROM_WORKFLOW;
          if (!prNumber && context.payload.issue) {
            prNumber = context.payload.issue.number;
          }
          
          if (!prNumber) {
            console.log('‚è≠Ô∏è No PR to process');
            return;
          }
          
          prNumber = parseInt(prNumber);
          console.log(`ü§ñ Jules PR Auto-Merge: #${prNumber}`);
          
          // Get latest PR state
          const { data: pr } = await github.rest.pulls.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: prNumber
          });
          
          // Check if it's a Jules PR
          const isJulesPR = pr.labels.some(l => l.name === 'jules-pr') || 
                           (pr.body && pr.body.includes('Created by Jules'));
          if (!isJulesPR) {
            console.log('‚è≠Ô∏è Not a Jules PR - skipping');
            return;
          }
          
          // Check mergeable state
          if (pr.mergeable === false) {
            console.log('‚ùå PR is not mergeable');
            return;
          }
          
          // Get check suites
          const { data: checkSuites } = await github.rest.checks.listSuitesForRef({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: pr.head.sha
          });
          
          let allChecksPassed = true;
          for (const suite of checkSuites.check_suites) {
            if (suite.conclusion === 'failure' || suite.conclusion === 'error') {
              allChecksPassed = false;
              break;
            }
          }
          
          if (!allChecksPassed) {
            console.log('‚ùå Not all checks passed - cannot auto-merge');
            return;
          }
          
          // Auto-merge if enabled
          if (process.env.AUTO_MERGE_ENABLED === 'true') {
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              merge_method: 'squash'
            });
            console.log('‚úÖ Auto-merged Jules PR');
            
            // Update CHANGELOG.md (existing logic, assuming it's in CI-06)
            // Note: Actual changelog update is handled by CI-06_update-changelog.yml
          } else {
            console.log('‚è≠Ô∏è Auto-merge disabled');
          }
