name: "CI-05: PR Auto-Merge"

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled]
  check_suite:
    types: [completed]
  workflow_run:
    workflows: ["CI-01: Build & Test"]
    types: [completed]
  workflow_dispatch:

env:
  # Set to 'false' to disable auto-merge temporarily
  AUTO_MERGE_ENABLED: true

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: read

jobs:
  # Auto-merge for Jules PRs with failure handling
  auto-merge:
    name: Auto-Merge Jules PR
    runs-on: ubuntu-latest
    if: |
      (github.event.pull_request &&
       (contains(github.event.pull_request.labels.*.name, 'jules-pr') || 
        contains(github.event.pull_request.body, 'Created by Jules')) &&
       github.event.pull_request.draft == false &&
       env.AUTO_MERGE_ENABLED == 'true') ||
      (github.event.workflow_run &&
       github.event.workflow_run.conclusion != 'skipped' &&
       env.AUTO_MERGE_ENABLED == 'true') ||
      github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Find Jules PR for workflow run
      id: find-pr
      if: github.event_name == 'workflow_run'
      uses: actions/github-script@v7
      with:
        script: |
          const run = context.payload.workflow_run;
          const { data: prs } = await github.rest.pulls.list({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open'
          });
          
          // Find PR matching the workflow run head SHA
          const pr = prs.find(p => 
            p.head.sha === run.head_sha &&
            (p.labels.some(l => l.name === 'jules-pr') || (p.body && p.body.includes('Created by Jules')))
          );
          
          if (pr) {
            core.setOutput('pr_number', pr.number);
            core.setOutput('has_pr', 'true');
          } else {
            core.setOutput('has_pr', 'false');
          }

    - name: Auto-merge Jules PR if all checks pass
      uses: actions/github-script@v7
      env:
        PR_FROM_EVENT: ${{ github.event.pull_request.number || '' }}
        PR_FROM_WORKFLOW: ${{ steps.find-pr.outputs.pr_number || '' }}
      with:
        script: |
          // Determine PR number
          let prNumber = process.env.PR_FROM_EVENT || process.env.PR_FROM_WORKFLOW;
          if (!prNumber && context.payload.issue) {
            prNumber = context.payload.issue.number;
          }
          
          if (!prNumber) {
            console.log('‚è≠Ô∏è No PR to process');
            return;
          }
          
          prNumber = parseInt(prNumber);
          console.log(`ü§ñ Jules PR Auto-Merge: #${prNumber}`);
          
          // Get latest PR state
          const { data: pr } = await github.rest.pulls.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: prNumber
          });
          
          // Check if it's a Jules PR
          const isJulesPR = pr.labels.some(l => l.name === 'jules-pr') || 
                           (pr.body && pr.body.includes('Created by Jules'));
          if (!isJulesPR) {
            console.log('‚è≠Ô∏è Not a Jules PR - skipping');
            return;
          }
          
          // Check mergeable state
          if (pr.mergeable === false) {
            console.log('‚ùå Merge conflicts detected');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `@jules ‚ö†Ô∏è **Merge Conflicts Detected**\n\nThis PR has merge conflicts that need to be resolved before it can be merged. Please update your branch with the latest changes from the base branch and resolve any conflicts.`
            });
            return;
          }
          
          // Get check runs with retry logic for robustness
          let checkRuns;
          let retryCount = 0;
          const maxRetries = 3;
          
          while (retryCount < maxRetries) {
            try {
              const response = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha,
                per_page: 100
              });
              checkRuns = response.data;
              break;
            } catch (error) {
              retryCount++;
              if (retryCount >= maxRetries) {
                console.error(`‚ùå Failed to fetch check runs after ${maxRetries} attempts: ${error.message}`);
                throw error;
              }
              console.log(`‚ö†Ô∏è Retry ${retryCount}/${maxRetries} fetching check runs...`);
              await new Promise(resolve => setTimeout(resolve, 2000 * retryCount));
            }
          }
          
          // Get commit statuses as well (some checks use statuses instead of check runs)
          let commitStatuses;
          try {
            const statusResponse = await github.rest.repos.getCombinedStatusForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.head.sha
            });
            commitStatuses = statusResponse.data.statuses || [];
          } catch (error) {
            console.log(`‚ö†Ô∏è Could not fetch commit statuses: ${error.message}`);
            commitStatuses = [];
          }
          
          // Filter out self-referencing checks
          const relevantChecks = checkRuns.check_runs.filter(check => 
            check.name !== 'Auto-Merge Jules PR' && 
            check.name !== 'auto-merge'
          );
          
          // Check for required status checks from branch protection
          let requiredChecks = [];
          try {
            const branchProtection = await github.rest.repos.getBranchProtection({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: pr.base.ref
            }).catch(() => null);
            
            if (branchProtection?.data?.required_status_checks?.contexts) {
              requiredChecks = branchProtection.data.required_status_checks.contexts;
              console.log(`üìã Required checks from branch protection: ${requiredChecks.join(', ')}`);
            }
          } catch (error) {
            console.log(`‚ö†Ô∏è Could not fetch branch protection rules: ${error.message}`);
          }
          
          // Combine check runs and commit statuses for complete picture
          const allChecks = [
            ...relevantChecks.map(check => ({
              name: check.name,
              conclusion: check.conclusion,
              status: check.status,
              type: 'check_run',
              details_url: check.details_url,
              summary: check.output?.summary,
              started_at: check.started_at,
              completed_at: check.completed_at
            })),
            ...commitStatuses.map(status => ({
              name: status.context,
              conclusion: status.state === 'success' ? 'success' : (status.state === 'pending' ? null : 'failure'),
              status: status.state === 'pending' ? 'in_progress' : 'completed',
              type: 'status',
              details_url: status.target_url,
              summary: status.description
            }))
          ];
          
          console.log(`üìä Total checks found: ${allChecks.length} (${relevantChecks.length} check runs, ${commitStatuses.length} statuses)`);
          
          // Check completion status
          const allChecksPassed = allChecks.every(check => 
            check.conclusion === 'success' || check.conclusion === 'skipped' || check.conclusion === 'neutral'
          );
          
          const anyPending = allChecks.some(check => 
            check.conclusion === null || 
            check.status === 'in_progress' || 
            check.status === 'queued' ||
            check.status === 'pending'
          );
          
          const failedChecks = allChecks.filter(check => 
            check.conclusion === 'failure' || 
            check.conclusion === 'cancelled' ||
            check.conclusion === 'timed_out' ||
            check.conclusion === 'action_required'
          );
          
          // Log detailed status
          console.log(`‚úÖ Passed: ${allChecks.filter(c => c.conclusion === 'success').length}`);
          console.log(`‚è≥ Pending: ${allChecks.filter(c => c.conclusion === null || c.status === 'in_progress' || c.status === 'queued' || c.status === 'pending').length}`);
          console.log(`‚ùå Failed: ${failedChecks.length}`);
          console.log(`‚è≠Ô∏è Skipped: ${allChecks.filter(c => c.conclusion === 'skipped').length}`);
          
          if (anyPending) {
            const pendingChecks = allChecks.filter(c => 
              c.conclusion === null || 
              c.status === 'in_progress' || 
              c.status === 'queued' ||
              c.status === 'pending'
            );
            console.log(`‚è≥ Checks still running (${pendingChecks.length}): ${pendingChecks.map(c => c.name).join(', ')}`);
            return;
          }
          
          // Check if we have any checks at all (avoid auto-merge with no checks)
          if (allChecks.length === 0 && requiredChecks.length === 0) {
            console.log('‚ö†Ô∏è No checks found and no required checks configured. Waiting for checks to start...');
            return;
          }
          
          if (!allChecksPassed) {
            console.log(`‚ùå ${failedChecks.length} check(s) failed - notifying Jules`);
            
            // Create detailed failure report with enhanced information
            let failureReport = '## ‚ùå Failed Checks Summary\n\n';
            failureReport += `**Total Checks:** ${allChecks.length} | **Failed:** ${failedChecks.length} | **Passed:** ${allChecks.filter(c => c.conclusion === 'success').length}\n\n`;
            failureReport += '### Failed Checks Details\n\n';
            
            for (const check of failedChecks) {
              const emoji = check.conclusion === 'cancelled' ? 'üö´' : 
                           check.conclusion === 'timed_out' ? '‚è±Ô∏è' : 
                           check.conclusion === 'action_required' ? '‚ö†Ô∏è' : '‚ùå';
              
              failureReport += `${emoji} **${check.name}** (${check.type})\n`;
              failureReport += `   - **Status:** ${check.conclusion}\n`;
              
              if (check.summary) {
                const truncatedSummary = check.summary.length > 200 
                  ? check.summary.substring(0, 200) + '...' 
                  : check.summary;
                failureReport += `   - **Summary:** ${truncatedSummary}\n`;
              }
              
              if (check.details_url) {
                failureReport += `   - **Details:** [View Full Log](${check.details_url})\n`;
              }
              
              if (check.started_at && check.completed_at) {
                const duration = Math.round((new Date(check.completed_at) - new Date(check.started_at)) / 1000);
                failureReport += `   - **Duration:** ${duration}s\n`;
              }
              
              failureReport += '\n';
            }
            
            failureReport += '\n### üîß Next Steps\n\n';
            failureReport += '1. Click on the "View Full Log" links above to see detailed error messages\n';
            failureReport += '2. Fix the issues in your code\n';
            failureReport += '3. Push the changes to update this PR\n';
            failureReport += '4. Checks will automatically re-run and auto-merge will retry when they pass\n';
            
            if (failedChecks.some(c => c.name.includes('test'))) {
              failureReport += '\nüí° **Tip:** Test failures often indicate logic errors. Run tests locally to debug faster.\n';
            }
            if (failedChecks.some(c => c.name.includes('lint') || c.name.includes('format'))) {
              failureReport += '\nüí° **Tip:** Run `cargo fmt` and `cargo clippy` locally to fix formatting and lint issues.\n';
            }
            if (failedChecks.some(c => c.name.includes('build'))) {
              failureReport += '\nüí° **Tip:** Build failures might be due to compilation errors or missing dependencies.\n';
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `@jules ‚ö†Ô∏è **Checks Failed - Action Required**\n\n${failureReport}`
            });
            return;
          }
          
          // Check for requested changes
          const { data: reviews } = await github.rest.pulls.listReviews({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: prNumber
          });
          
          const hasRequestedChanges = reviews.some(r => r.state === 'CHANGES_REQUESTED');
          if (hasRequestedChanges) {
            console.log('‚ùå Changes requested - cannot auto-merge');
            return;
          }
          
          // All good - merge!
          console.log('‚úÖ All checks passed - merging...');
          
          try {
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              commit_title: `ü§ñ Auto-merge: ${pr.title}`,
              commit_message: `Jules PR #${prNumber} - All checks passed\n\n${pr.body || ''}`,
              merge_method: 'squash'
            });
            
            console.log('‚úÖ Merged successfully!');
            
            // Add success comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `‚úÖ **Auto-merged successfully!** All checks passed and the PR has been merged.`
            });
            
            // Store PR number for next workflow
            core.setOutput('merged_pr', prNumber);
            core.setOutput('pr_merged', 'true');
            
          } catch (error) {
            console.error('‚ùå Merge failed:', error.message);
            
            // Provide detailed error analysis
            let errorAnalysis = '### üîç Error Analysis\n\n';
            let nextSteps = '### üîß Next Steps\n\n';
            
            if (error.message.includes('merge conflict') || error.message.includes('conflict')) {
              errorAnalysis += '**Cause:** Merge conflicts detected\n';
              nextSteps += '1. Update your branch with the latest changes from the base branch\n';
              nextSteps += '2. Resolve any conflicts locally\n';
              nextSteps += '3. Push the resolved changes\n';
            } else if (error.message.includes('required status check') || error.message.includes('branch protection')) {
              errorAnalysis += '**Cause:** Branch protection requirements not met\n';
              nextSteps += '1. Ensure all required status checks have passed\n';
              nextSteps += '2. Check if review approvals are required\n';
              nextSteps += '3. Verify branch is up to date with base\n';
            } else if (error.message.includes('not mergeable') || error.message.includes('mergeable_state')) {
              errorAnalysis += '**Cause:** PR is not in a mergeable state\n';
              nextSteps += '1. Wait for all checks to complete\n';
              nextSteps += '2. Refresh the PR status\n';
              nextSteps += '3. Check for merge conflicts\n';
            } else {
              errorAnalysis += `**Cause:** ${error.message}\n`;
              nextSteps += '1. Review the error message above\n';
              nextSteps += '2. Check the PR status manually\n';
              nextSteps += '3. Contact maintainers if issue persists\n';
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `@jules ‚ö†Ô∏è **Auto-merge Failed**\n\n${errorAnalysis}\n${nextSteps}\n---\n**Technical Details:** \`${error.message}\``
            });
          }
